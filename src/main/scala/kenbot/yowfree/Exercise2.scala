package kenbot.yowfree

import scala.annotation.tailrec
import Trampolines._

object ListAppendNaughtyRecursion extends ListAppendProgram {

  /**
   * Overflows the stack for large lists, because the algorithm is not tail-recursive.
   * Try running it with "sbt run" -- KABLAMMO!
   */
  def listAppend[A](list1: List[A], list2: List[A]): List[A] = list1 match {
    case Nil => list2
    case head :: tail => head :: listAppend(tail, list2)
  }

  def runSolution[A](list1: List[A], list2: List[A]): List[A] = listAppend(list1, list2)
}


object Trampolines {

  /**
   * A Trampoline[A], which lets us recurse on the heap rather than the stack, is just
   * the Free Monad generated by the Function0 functor.
   */
  type Trampoline[+A] = Free[Function0, A]

  /**
   * Exercise 2a. 
   *
   * Write an interpreter for trampolines. 
   *
   * Hint: Remember that Trampoline[A] is Free[Function0, A] -- there are only 2 things we can do 
   * with a Free -- flatMap, because it is a monad, and pattern matching, which can destructure it
   * into Suspend or Return.
   */
  @tailrec
  final def runTrampoline[A](trampoline: Trampoline[A]): A = trampoline match {
    case Return(a) => a
    case Suspend(next) => runTrampoline(next())
  }
}


object ListAppendRighteousTrampoline extends ListAppendProgram {

  /**
   * Exercise 2b.
   *
   * Implement the same algorithm, this time using a trampoline instead.  
   * This should get the same result, but not blow the stack.
   *
   * Hint:
   * This is a simple mechanical translation of the original algorithm. 
   * Consider: the algorithm has 2 cases, one to recurse, and one to terminate and return.
   * A Free also has 2 cases: Suspend which recurses, and Return which terminates and returns.
   *
   */
  def listAppend[A](list1: List[A], list2: List[A]): Trampoline[List[A]] = list1 match {
    case Nil => Return(list2)
    case head :: tail => Suspend(() => for {
      h <- Return(head)
      ll <- listAppend(tail, list2)
    } yield h :: ll)
  }


  def runSolution[A](list1: List[A], list2: List[A]): List[A] = runTrampoline(listAppend(list1, list2))
}


trait ListAppendProgram {

  def runSolution[A](list1: List[A], list2: List[A]): List[A]

  val list1 = (1 to 9999).toList
  val list2 = (10000 to 20000).toList

  def main(args: Array[String]): Unit = {
    println("Starting")
    val result = runSolution(list1, list2)
    println(s"Appended paths: ${result.take(5).mkString(", ")}... and many more")
  }

}


