package kenbot.yowfree

import scalaz._
import Scalaz._
import scalaz.{Free => _}


/** 
 * The Free monad generated by some functor F.
 * 
 * Free is a tree-like structure, which either recurses with Suspend or terminates
 * yielding a pure value with Return.  The branching factor is provided by 
 * functor F.  
 * 
 * It is a very versatile structure, and has many interesting and useful properties. 
 * 
 * The most common usage is to separate the representation of a program from its 
 * interpretation -- this a powerful tool for pushing side-effects away 
 * from your pure logic.
 * 
 * But first.... let's implement it!
 */
trait Free[F[_], +A] {

  def flatMap[B](f: A => Free[F, B])
                (implicit F: Functor[F]): Free[F, B]

  def map[B](f: A => B)
            (implicit F: Functor[F]): Free[F, B]
}




case class Return[F[_], +A](a: A) extends Free[F, A] {
  
  /**
   * Exercise 1a.
   * 
   * If it's going to be a monad, we're going to need flatMap.
   * 
   * Implement flatMap and map for Return. 
   */
  override def flatMap[B](f: A => Free[F, B])
                         (implicit F: Functor[F]): Free[F, B] = ???
                         
  override def map[B](f: A => B)
                     (implicit F: Functor[F]): Free[F, B] = ???
}



case class Suspend[F[_], A](next: F[Free[F, A]]) extends Free[F, A] {
  /**
   * Exercise 1b.
   * 
   * Now implement flatMap and map for Suspend. 
   * 
   * In order to get the monad "for free" in the Category Theory 
   * sense, it has to:
   * - Be nothing other than a monad.
   * - Use nothing else other than (in this case) the functor F to become a monad.
   * 
   * Consider:
   * - We _have_ to use our functor F; otherwise it doesn't count as a free monad.
   * - Similarly, we _can't_ use anything outside of F or Free.
   * - There's only one thing you can do with a functor.
   * - There's only one thing you can do with a monad.
   * - You're allowed to use our two Free constructors, Suspend and Return.
   * - If you're stuck, look at the type signatures! Just fit the puzzle pieces together.
   */
  override def flatMap[B](f: A => Free[F, B])
                         (implicit F: Functor[F]): Free[F, B] = ???
                         
  override def map[B](f: A => B)
                     (implicit F: Functor[F]): Free[F, B] = ???
}

object Free {

  /**
   * Exercise 1c.
   * 
   * Implement liftF, lifting a functor into its free monad.
   * 
   * Hint: If it won't typecheck, try explicitly providing the [F,A] 
   * type parameters where appropriate in the function.
   */
  def liftF[F[_]: Functor, A](fa: F[A]): Free[F, A] = ???

}





