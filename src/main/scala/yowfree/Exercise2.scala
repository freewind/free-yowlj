package yowfree

import scala.annotation.tailrec


object ListAppendNaughtyRecursion extends ListAppendProgram {
  
  /**
   * Overflows the stack for large lists, because the algorithm is not tail-recursive.
   */
  def listAppend[A](list1: List[A], list2: List[A]): List[A] = list1 match {
    case Nil => list2
    case head :: tail => head :: listAppend(tail, list2)
  }
  
  def runTest[A](list1: List[A], list2: List[A]): List[A] = listAppend(list1, list2)
}


trait Trampolines {
  
  /**
   * A Trampoline[A], which lets us recurse on the heap rather than the stack, is just
   * the Free Monad generated by the Function0 functor.
   */
  type Trampoline[+A] = Free[Function0, A]

  /**
   * Exercise 2a. 
   * 
   * Write an interpreter for trampolines. 
   */
  @tailrec
  final def runTrampoline[A](trampoline: Trampoline[A]): A = trampoline match {
    case Suspend(f0) => runTrampoline(f0())
    case Return(a) => a
  }
}


object ListAppendRighteousTrampoline extends ListAppendProgram {
  
  /**
   * Exercise 2b.
   * 
   * Implement the same algorithm, this time using a trampoline instead.  
   * This should get the same result, but not blow the stack.
   * 
   */
  def listAppend[A](list1: List[A], list2: List[A]): Trampoline[List[A]] = list1 match {
    case Nil => Return(list2)
    case head :: tail => Suspend(() => listAppend(tail, list2).map(head :: _))
  }

  def runTest[A](list1: List[A], list2: List[A]): List[A] = runTrampoline(listAppend(list1, list2))
}



trait ListAppendProgram extends Trampolines {
  
  def runTest[A](list1: List[A], list2: List[A]): List[A]
  
  val list1 = (1 to 9999).toList
  val list2 = (10000 to 20000).toList
  
  def main(args: Array[String]): Unit = {
    println("Starting")
    val result = runTest(list1, list2)
    println(s"Appended paths: ${result.take(5).mkString(", ")}... and many more")
  }

}


