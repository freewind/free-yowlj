package yowfree

import scala.annotation.tailrec

sealed trait BinTree
case class Node(left: BinTree, right: BinTree) extends BinTree
case class Leaf(n: Int) extends BinTree


object ZigZagNaughtyRecursion extends ZigZagProgram {
  
  def zigZag(tree: BinTree): Int = {
    
    def zig(t: BinTree): Int = t match {
      case Node(left, right) => zag(left)
      case Leaf(n) => n
    }
    
    def zag(t: BinTree): Int = t match {
      case Node(left, right) => zig(right)
      case Leaf(n) => n
    }
      
    zig(tree)
  }
  
  def runTest(tree: BinTree): Int = zigZag(tree)
}


trait Trampolines {
  
  /**
   * A Trampoline[A], which lets us recurse on the heap rather than the stack, is just
   * the Free Monad generated by the Function0 functor.
   */
  type Trampoline[+A] = Free[Function0, A]
  
  /**
   * Convenient Suspend constructor for trampolines
   */
  def TSuspend[A](ffa: Function0[Trampoline[A]]): Trampoline[A] = Suspend(ffa)
  
  /**
   * Convenient Return constructor for trampolines
   */
  def TReturn[A](a: A): Trampoline[A] = Return(a)
  
  /**
   * Interpreter for trampolines
   */
  @tailrec
  final def runTrampoline[A](trampoline: Trampoline[A]): A = trampoline match {
    case Suspend(f0) => runTrampoline(f0())
    case Return(a) => a
  }
}


object ZigZagRighteousTrampoline extends ZigZagProgram {
  
  def zigZag(tree: BinTree): Trampoline[Int] = {
    def zig(t: BinTree): Trampoline[Int] = t match {
      case Node(left, right) => Suspend(() => zag(left))
      case Leaf(n) => Return(n)
    }
    
    def zag(t: BinTree): Trampoline[Int] = t match {
      case Node(left, right) => Suspend(() => zig(right))
      case Leaf(n) => Return(n)
    }
      
    zig(tree)
  }

  def runTest(tree: BinTree): Int = runTrampoline(zigZag(tree))
}



trait ZigZagProgram extends Trampolines {
  
  def runTest(tree: BinTree): Int
  
  val bigTree: BinTree = generateTree(0 to 1000000)
  
  def main(args: Array[String]): Unit = {
    println("Starting")
    val result = runTest(bigTree)
    println(s"Zigzag path result: $result")
  }
  

  def generateTree(ints: Iterable[Int]): BinTree = {
        type BinTreePair = (BinTree, BinTree)
    
    def pairOffTrees(trees: List[BinTree]): List[BinTreePair] = {
      @tailrec
      def pair(treesLeft: List[BinTree], 
               pairsSoFar: List[BinTreePair]): List[BinTreePair] = treesLeft match {
        
        case a :: b :: rest => pair(rest, (a,b) :: pairsSoFar)
        case _ => pairsSoFar
      }
      pair(trees, Nil)
    }
    
    def buildTrees(trees: List[BinTree]): List[BinTree] = {
      @tailrec
      def joinPairs(pairsLeft: List[BinTreePair], 
                 treesSoFar: List[BinTree]): List[BinTree] = pairsLeft match {
        case Nil => treesSoFar
        case (a,b) :: rest => joinPairs(rest, Node(a,b) :: treesSoFar)
      }
      joinPairs(pairOffTrees(trees), Nil)
    }

    @tailrec
    def reduceTrees(trees: List[BinTree]): BinTree = trees match {
      case Nil => Leaf(0)
      case t :: Nil => t
      case _ => reduceTrees(buildTrees(trees))
    }

    val leaves = ints.toList map Leaf.apply
    reduceTrees(leaves)
  }
}


